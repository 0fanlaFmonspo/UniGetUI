#pragma once
// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.210503.1

#ifndef WINRT_Microsoft_Management_Deployment_H
#define WINRT_Microsoft_Management_Deployment_H
#include "winrt/base.h"
#define CPPWINRT_VERSION "2.0.210503.1"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.System.2.h"
#include "winrt/impl/Microsoft.Management.Deployment.2.h"
namespace winrt::impl
{
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::AuthenticationMode) consume_Microsoft_Management_Deployment_IAuthenticationArguments<D>::AuthenticationMode() const
    {
        winrt::Microsoft::Management::Deployment::AuthenticationMode value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IAuthenticationArguments)->get_AuthenticationMode(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IAuthenticationArguments<D>::AuthenticationMode(winrt::Microsoft::Management::Deployment::AuthenticationMode const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IAuthenticationArguments)->put_AuthenticationMode(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IAuthenticationArguments<D>::AuthenticationAccount() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IAuthenticationArguments)->get_AuthenticationAccount(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IAuthenticationArguments<D>::AuthenticationAccount(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IAuthenticationArguments)->put_AuthenticationAccount(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::AuthenticationType) consume_Microsoft_Management_Deployment_IAuthenticationInfo<D>::AuthenticationType() const
    {
        winrt::Microsoft::Management::Deployment::AuthenticationType value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IAuthenticationInfo)->get_AuthenticationType(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::MicrosoftEntraIdAuthenticationInfo) consume_Microsoft_Management_Deployment_IAuthenticationInfo<D>::MicrosoftEntraIdAuthenticationInfo() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IAuthenticationInfo)->get_MicrosoftEntraIdAuthenticationInfo(&value));
        return winrt::Microsoft::Management::Deployment::MicrosoftEntraIdAuthenticationInfo{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackage<D>::Id() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackage)->get_Id(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackage<D>::Name() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackage)->get_Name(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageVersionInfo) consume_Microsoft_Management_Deployment_ICatalogPackage<D>::InstalledVersion() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackage)->get_InstalledVersion(&value));
        return winrt::Microsoft::Management::Deployment::PackageVersionInfo{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageVersionId>) consume_Microsoft_Management_Deployment_ICatalogPackage<D>::AvailableVersions() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackage)->get_AvailableVersions(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageVersionId>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageVersionInfo) consume_Microsoft_Management_Deployment_ICatalogPackage<D>::DefaultInstallVersion() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackage)->get_DefaultInstallVersion(&value));
        return winrt::Microsoft::Management::Deployment::PackageVersionInfo{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageVersionInfo) consume_Microsoft_Management_Deployment_ICatalogPackage<D>::GetPackageVersionInfo(winrt::Microsoft::Management::Deployment::PackageVersionId const& versionKey) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackage)->GetPackageVersionInfo(*(void**)(&versionKey), &result));
        return winrt::Microsoft::Management::Deployment::PackageVersionInfo{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_ICatalogPackage<D>::IsUpdateAvailable() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackage)->get_IsUpdateAvailable(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult>) consume_Microsoft_Management_Deployment_ICatalogPackage2<D>::CheckInstalledStatusAsync(winrt::Microsoft::Management::Deployment::InstalledStatusType const& checkTypes) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackage2)->CheckInstalledStatusAsync(static_cast<uint32_t>(checkTypes), &operation));
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult) consume_Microsoft_Management_Deployment_ICatalogPackage2<D>::CheckInstalledStatus(winrt::Microsoft::Management::Deployment::InstalledStatusType const& checkTypes) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackage2)->CheckInstalledStatus(static_cast<uint32_t>(checkTypes), &result));
        return winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult>) consume_Microsoft_Management_Deployment_ICatalogPackage2<D>::CheckInstalledStatusAsync() const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackage2)->CheckInstalledStatusAsync2(&operation));
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult) consume_Microsoft_Management_Deployment_ICatalogPackage2<D>::CheckInstalledStatus() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackage2)->CheckInstalledStatus2(&result));
        return winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::Locale() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_Locale(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::Publisher() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_Publisher(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::PublisherUrl() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_PublisherUrl(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::PublisherSupportUrl() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_PublisherSupportUrl(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::PrivacyUrl() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_PrivacyUrl(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::Author() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_Author(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::PackageName() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_PackageName(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::PackageUrl() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_PackageUrl(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::License() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_License(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::LicenseUrl() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_LicenseUrl(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::Copyright() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_Copyright(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::CopyrightUrl() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_CopyrightUrl(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::ShortDescription() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_ShortDescription(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::Description() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_Description(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<hstring>) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::Tags() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_Tags(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageAgreement>) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::Agreements() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_Agreements(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageAgreement>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::Documentation>) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::Documentations() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_Documentations(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::Documentation>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::Icon>) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::Icons() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_Icons(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::Icon>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::ReleaseNotes() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_ReleaseNotes(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::ReleaseNotesUrl() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_ReleaseNotesUrl(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::PurchaseUrl() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_PurchaseUrl(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ICatalogPackageMetadata<D>::InstallationNotes() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata)->get_InstallationNotes(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::CheckInstalledStatusResultStatus) consume_Microsoft_Management_Deployment_ICheckInstalledStatusResult<D>::Status() const
    {
        winrt::Microsoft::Management::Deployment::CheckInstalledStatusResultStatus value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICheckInstalledStatusResult)->get_Status(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageInstallerInstalledStatus>) consume_Microsoft_Management_Deployment_ICheckInstalledStatusResult<D>::PackageInstalledStatus() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICheckInstalledStatusResult)->get_PackageInstalledStatus(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageInstallerInstalledStatus>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::ConnectResultStatus) consume_Microsoft_Management_Deployment_IConnectResult<D>::Status() const
    {
        winrt::Microsoft::Management::Deployment::ConnectResultStatus value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IConnectResult)->get_Status(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageCatalog) consume_Microsoft_Management_Deployment_IConnectResult<D>::PackageCatalog() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IConnectResult)->get_PackageCatalog(&value));
        return winrt::Microsoft::Management::Deployment::PackageCatalog{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Management::Deployment::PackageCatalogReference>) consume_Microsoft_Management_Deployment_ICreateCompositePackageCatalogOptions<D>::Catalogs() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICreateCompositePackageCatalogOptions)->get_Catalogs(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Management::Deployment::PackageCatalogReference>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::CompositeSearchBehavior) consume_Microsoft_Management_Deployment_ICreateCompositePackageCatalogOptions<D>::CompositeSearchBehavior() const
    {
        winrt::Microsoft::Management::Deployment::CompositeSearchBehavior value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICreateCompositePackageCatalogOptions)->get_CompositeSearchBehavior(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_ICreateCompositePackageCatalogOptions<D>::CompositeSearchBehavior(winrt::Microsoft::Management::Deployment::CompositeSearchBehavior const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICreateCompositePackageCatalogOptions)->put_CompositeSearchBehavior(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageInstallScope) consume_Microsoft_Management_Deployment_ICreateCompositePackageCatalogOptions2<D>::InstalledScope() const
    {
        winrt::Microsoft::Management::Deployment::PackageInstallScope value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICreateCompositePackageCatalogOptions2)->get_InstalledScope(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_ICreateCompositePackageCatalogOptions2<D>::InstalledScope(winrt::Microsoft::Management::Deployment::PackageInstallScope const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ICreateCompositePackageCatalogOptions2)->put_InstalledScope(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IDocumentation<D>::DocumentLabel() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDocumentation)->get_DocumentLabel(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IDocumentation<D>::DocumentUrl() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDocumentation)->get_DocumentUrl(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageVersionId) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::PackageVersionId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->get_PackageVersionId(&value));
        return winrt::Microsoft::Management::Deployment::PackageVersionId{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::PackageVersionId(winrt::Microsoft::Management::Deployment::PackageVersionId const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->put_PackageVersionId(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageInstallerType) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::InstallerType() const
    {
        winrt::Microsoft::Management::Deployment::PackageInstallerType value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->get_InstallerType(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::InstallerType(winrt::Microsoft::Management::Deployment::PackageInstallerType const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->put_InstallerType(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageInstallScope) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::Scope() const
    {
        winrt::Microsoft::Management::Deployment::PackageInstallScope value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->get_Scope(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::Scope(winrt::Microsoft::Management::Deployment::PackageInstallScope const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->put_Scope(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::System::ProcessorArchitecture) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::Architecture() const
    {
        winrt::Windows::System::ProcessorArchitecture value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->get_Architecture(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::Architecture(winrt::Windows::System::ProcessorArchitecture const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->put_Architecture(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::Locale() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->get_Locale(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::Locale(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->put_Locale(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::DownloadDirectory() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->get_DownloadDirectory(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::DownloadDirectory(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->put_DownloadDirectory(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::AllowHashMismatch() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->get_AllowHashMismatch(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::AllowHashMismatch(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->put_AllowHashMismatch(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::SkipDependencies() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->get_SkipDependencies(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::SkipDependencies(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->put_SkipDependencies(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::AcceptPackageAgreements() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->get_AcceptPackageAgreements(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::AcceptPackageAgreements(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->put_AcceptPackageAgreements(value));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::CorrelationData() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->get_CorrelationData(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IDownloadOptions<D>::CorrelationData(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadOptions)->put_CorrelationData(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IDownloadResult<D>::CorrelationData() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadResult)->get_CorrelationData(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::DownloadResultStatus) consume_Microsoft_Management_Deployment_IDownloadResult<D>::Status() const
    {
        winrt::Microsoft::Management::Deployment::DownloadResultStatus value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadResult)->get_Status(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::hresult) consume_Microsoft_Management_Deployment_IDownloadResult<D>::ExtendedErrorCode() const
    {
        winrt::hresult value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IDownloadResult)->get_ExtendedErrorCode(put_abi(value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Management::Deployment::PackageMatchFilter>) consume_Microsoft_Management_Deployment_IFindPackagesOptions<D>::Selectors() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IFindPackagesOptions)->get_Selectors(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Management::Deployment::PackageMatchFilter>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Management::Deployment::PackageMatchFilter>) consume_Microsoft_Management_Deployment_IFindPackagesOptions<D>::Filters() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IFindPackagesOptions)->get_Filters(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Management::Deployment::PackageMatchFilter>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(uint32_t) consume_Microsoft_Management_Deployment_IFindPackagesOptions<D>::ResultLimit() const
    {
        uint32_t value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IFindPackagesOptions)->get_ResultLimit(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IFindPackagesOptions<D>::ResultLimit(uint32_t value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IFindPackagesOptions)->put_ResultLimit(value));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::FindPackagesResultStatus) consume_Microsoft_Management_Deployment_IFindPackagesResult<D>::Status() const
    {
        winrt::Microsoft::Management::Deployment::FindPackagesResultStatus value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IFindPackagesResult)->get_Status(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::MatchResult>) consume_Microsoft_Management_Deployment_IFindPackagesResult<D>::Matches() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IFindPackagesResult)->get_Matches(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::MatchResult>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IFindPackagesResult<D>::WasLimitExceeded() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IFindPackagesResult)->get_WasLimitExceeded(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IIcon<D>::Url() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IIcon)->get_Url(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::IconFileType) consume_Microsoft_Management_Deployment_IIcon<D>::FileType() const
    {
        winrt::Microsoft::Management::Deployment::IconFileType value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IIcon)->get_FileType(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::IconResolution) consume_Microsoft_Management_Deployment_IIcon<D>::Resolution() const
    {
        winrt::Microsoft::Management::Deployment::IconResolution value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IIcon)->get_Resolution(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::IconTheme) consume_Microsoft_Management_Deployment_IIcon<D>::Theme() const
    {
        winrt::Microsoft::Management::Deployment::IconTheme value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IIcon)->get_Theme(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(com_array<uint8_t>) consume_Microsoft_Management_Deployment_IIcon<D>::Sha256() const
    {
        uint32_t value_impl_size{};
        uint8_t* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IIcon)->get_Sha256(&value_impl_size, &value));
        return com_array<uint8_t>{ value, value_impl_size, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageVersionId) consume_Microsoft_Management_Deployment_IInstallOptions<D>::PackageVersionId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->get_PackageVersionId(&value));
        return winrt::Microsoft::Management::Deployment::PackageVersionId{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions<D>::PackageVersionId(winrt::Microsoft::Management::Deployment::PackageVersionId const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->put_PackageVersionId(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IInstallOptions<D>::PreferredInstallLocation() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->get_PreferredInstallLocation(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions<D>::PreferredInstallLocation(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->put_PreferredInstallLocation(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageInstallScope) consume_Microsoft_Management_Deployment_IInstallOptions<D>::PackageInstallScope() const
    {
        winrt::Microsoft::Management::Deployment::PackageInstallScope value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->get_PackageInstallScope(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions<D>::PackageInstallScope(winrt::Microsoft::Management::Deployment::PackageInstallScope const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->put_PackageInstallScope(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageInstallMode) consume_Microsoft_Management_Deployment_IInstallOptions<D>::PackageInstallMode() const
    {
        winrt::Microsoft::Management::Deployment::PackageInstallMode value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->get_PackageInstallMode(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions<D>::PackageInstallMode(winrt::Microsoft::Management::Deployment::PackageInstallMode const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->put_PackageInstallMode(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IInstallOptions<D>::LogOutputPath() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->get_LogOutputPath(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions<D>::LogOutputPath(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->put_LogOutputPath(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IInstallOptions<D>::AllowHashMismatch() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->get_AllowHashMismatch(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions<D>::AllowHashMismatch(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->put_AllowHashMismatch(value));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IInstallOptions<D>::ReplacementInstallerArguments() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->get_ReplacementInstallerArguments(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions<D>::ReplacementInstallerArguments(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->put_ReplacementInstallerArguments(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IInstallOptions<D>::CorrelationData() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->get_CorrelationData(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions<D>::CorrelationData(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->put_CorrelationData(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IInstallOptions<D>::AdditionalPackageCatalogArguments() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->get_AdditionalPackageCatalogArguments(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions<D>::AdditionalPackageCatalogArguments(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions)->put_AdditionalPackageCatalogArguments(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Windows::System::ProcessorArchitecture>) consume_Microsoft_Management_Deployment_IInstallOptions2<D>::AllowedArchitectures() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions2)->get_AllowedArchitectures(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::System::ProcessorArchitecture>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IInstallOptions3<D>::AllowUpgradeToUnknownVersion() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions3)->get_AllowUpgradeToUnknownVersion(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions3<D>::AllowUpgradeToUnknownVersion(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions3)->put_AllowUpgradeToUnknownVersion(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IInstallOptions4<D>::Force() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions4)->get_Force(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions4<D>::Force(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions4)->put_Force(value));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IInstallOptions5<D>::AdditionalInstallerArguments() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions5)->get_AdditionalInstallerArguments(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions5<D>::AdditionalInstallerArguments(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions5)->put_AdditionalInstallerArguments(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IInstallOptions5<D>::AcceptPackageAgreements() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions5)->get_AcceptPackageAgreements(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions5<D>::AcceptPackageAgreements(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions5)->put_AcceptPackageAgreements(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IInstallOptions5<D>::BypassIsStoreClientBlockedPolicyCheck() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions5)->get_BypassIsStoreClientBlockedPolicyCheck(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions5<D>::BypassIsStoreClientBlockedPolicyCheck(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions5)->put_BypassIsStoreClientBlockedPolicyCheck(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IInstallOptions6<D>::SkipDependencies() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions6)->get_SkipDependencies(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions6<D>::SkipDependencies(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions6)->put_SkipDependencies(value));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageInstallerType) consume_Microsoft_Management_Deployment_IInstallOptions6<D>::InstallerType() const
    {
        winrt::Microsoft::Management::Deployment::PackageInstallerType value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions6)->get_InstallerType(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IInstallOptions6<D>::InstallerType(winrt::Microsoft::Management::Deployment::PackageInstallerType const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallOptions6)->put_InstallerType(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IInstallResult<D>::CorrelationData() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallResult)->get_CorrelationData(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IInstallResult<D>::RebootRequired() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallResult)->get_RebootRequired(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::InstallResultStatus) consume_Microsoft_Management_Deployment_IInstallResult<D>::Status() const
    {
        winrt::Microsoft::Management::Deployment::InstallResultStatus value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallResult)->get_Status(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::hresult) consume_Microsoft_Management_Deployment_IInstallResult<D>::ExtendedErrorCode() const
    {
        winrt::hresult value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallResult)->get_ExtendedErrorCode(put_abi(value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(uint32_t) consume_Microsoft_Management_Deployment_IInstallResult2<D>::InstallerErrorCode() const
    {
        uint32_t value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstallResult2)->get_InstallerErrorCode(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::InstalledStatusType) consume_Microsoft_Management_Deployment_IInstalledStatus<D>::Type() const
    {
        winrt::Microsoft::Management::Deployment::InstalledStatusType value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstalledStatus)->get_Type(reinterpret_cast<uint32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IInstalledStatus<D>::Path() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstalledStatus)->get_Path(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::hresult) consume_Microsoft_Management_Deployment_IInstalledStatus<D>::Status() const
    {
        winrt::hresult value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IInstalledStatus)->get_Status(put_abi(value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::CatalogPackage) consume_Microsoft_Management_Deployment_IMatchResult<D>::CatalogPackage() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IMatchResult)->get_CatalogPackage(&value));
        return winrt::Microsoft::Management::Deployment::CatalogPackage{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageMatchFilter) consume_Microsoft_Management_Deployment_IMatchResult<D>::MatchCriteria() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IMatchResult)->get_MatchCriteria(&value));
        return winrt::Microsoft::Management::Deployment::PackageMatchFilter{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IMicrosoftEntraIdAuthenticationInfo<D>::Resource() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IMicrosoftEntraIdAuthenticationInfo)->get_Resource(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IMicrosoftEntraIdAuthenticationInfo<D>::Scope() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IMicrosoftEntraIdAuthenticationInfo)->get_Scope(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageAgreement<D>::Label() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageAgreement)->get_Label(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageAgreement<D>::Text() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageAgreement)->get_Text(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageAgreement<D>::Url() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageAgreement)->get_Url(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IPackageCatalog<D>::IsComposite() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalog)->get_IsComposite(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageCatalogInfo) consume_Microsoft_Management_Deployment_IPackageCatalog<D>::Info() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalog)->get_Info(&value));
        return winrt::Microsoft::Management::Deployment::PackageCatalogInfo{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::FindPackagesResult>) consume_Microsoft_Management_Deployment_IPackageCatalog<D>::FindPackagesAsync(winrt::Microsoft::Management::Deployment::FindPackagesOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalog)->FindPackagesAsync(*(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::FindPackagesResult>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::FindPackagesResult) consume_Microsoft_Management_Deployment_IPackageCatalog<D>::FindPackages(winrt::Microsoft::Management::Deployment::FindPackagesOptions const& options) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalog)->FindPackages(*(void**)(&options), &result));
        return winrt::Microsoft::Management::Deployment::FindPackagesResult{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageCatalogInfo<D>::Id() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogInfo)->get_Id(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageCatalogInfo<D>::Name() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogInfo)->get_Name(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageCatalogInfo<D>::Type() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogInfo)->get_Type(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageCatalogInfo<D>::Argument() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogInfo)->get_Argument(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::DateTime) consume_Microsoft_Management_Deployment_IPackageCatalogInfo<D>::LastUpdateTime() const
    {
        winrt::Windows::Foundation::DateTime value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogInfo)->get_LastUpdateTime(put_abi(value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageCatalogOrigin) consume_Microsoft_Management_Deployment_IPackageCatalogInfo<D>::Origin() const
    {
        winrt::Microsoft::Management::Deployment::PackageCatalogOrigin value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogInfo)->get_Origin(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageCatalogTrustLevel) consume_Microsoft_Management_Deployment_IPackageCatalogInfo<D>::TrustLevel() const
    {
        winrt::Microsoft::Management::Deployment::PackageCatalogTrustLevel value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogInfo)->get_TrustLevel(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IPackageCatalogReference<D>::IsComposite() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference)->get_IsComposite(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageCatalogInfo) consume_Microsoft_Management_Deployment_IPackageCatalogReference<D>::Info() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference)->get_Info(&value));
        return winrt::Microsoft::Management::Deployment::PackageCatalogInfo{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::ConnectResult>) consume_Microsoft_Management_Deployment_IPackageCatalogReference<D>::ConnectAsync() const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference)->ConnectAsync(&operation));
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::ConnectResult>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::ConnectResult) consume_Microsoft_Management_Deployment_IPackageCatalogReference<D>::Connect() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference)->Connect(&result));
        return winrt::Microsoft::Management::Deployment::ConnectResult{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageCatalogReference2<D>::AdditionalPackageCatalogArguments() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference2)->get_AdditionalPackageCatalogArguments(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IPackageCatalogReference2<D>::AdditionalPackageCatalogArguments(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference2)->put_AdditionalPackageCatalogArguments(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::SourceAgreement>) consume_Microsoft_Management_Deployment_IPackageCatalogReference3<D>::SourceAgreements() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference3)->get_SourceAgreements(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::SourceAgreement>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IPackageCatalogReference3<D>::AcceptSourceAgreements() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference3)->get_AcceptSourceAgreements(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IPackageCatalogReference3<D>::AcceptSourceAgreements(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference3)->put_AcceptSourceAgreements(value));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::TimeSpan) consume_Microsoft_Management_Deployment_IPackageCatalogReference4<D>::PackageCatalogBackgroundUpdateInterval() const
    {
        winrt::Windows::Foundation::TimeSpan value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference4)->get_PackageCatalogBackgroundUpdateInterval(put_abi(value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IPackageCatalogReference4<D>::PackageCatalogBackgroundUpdateInterval(winrt::Windows::Foundation::TimeSpan const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference4)->put_PackageCatalogBackgroundUpdateInterval(impl::bind_in(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IPackageCatalogReference5<D>::InstalledPackageInformationOnly() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference5)->get_InstalledPackageInformationOnly(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IPackageCatalogReference5<D>::InstalledPackageInformationOnly(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference5)->put_InstalledPackageInformationOnly(value));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::AuthenticationArguments) consume_Microsoft_Management_Deployment_IPackageCatalogReference6<D>::AuthenticationArguments() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference6)->get_AuthenticationArguments(&value));
        return winrt::Microsoft::Management::Deployment::AuthenticationArguments{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IPackageCatalogReference6<D>::AuthenticationArguments(winrt::Microsoft::Management::Deployment::AuthenticationArguments const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference6)->put_AuthenticationArguments(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::AuthenticationInfo) consume_Microsoft_Management_Deployment_IPackageCatalogReference6<D>::AuthenticationInfo() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageCatalogReference6)->get_AuthenticationInfo(&value));
        return winrt::Microsoft::Management::Deployment::AuthenticationInfo{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageInstallerType) consume_Microsoft_Management_Deployment_IPackageInstallerInfo<D>::InstallerType() const
    {
        winrt::Microsoft::Management::Deployment::PackageInstallerType value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageInstallerInfo)->get_InstallerType(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageInstallerType) consume_Microsoft_Management_Deployment_IPackageInstallerInfo<D>::NestedInstallerType() const
    {
        winrt::Microsoft::Management::Deployment::PackageInstallerType value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageInstallerInfo)->get_NestedInstallerType(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::System::ProcessorArchitecture) consume_Microsoft_Management_Deployment_IPackageInstallerInfo<D>::Architecture() const
    {
        winrt::Windows::System::ProcessorArchitecture value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageInstallerInfo)->get_Architecture(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageInstallerScope) consume_Microsoft_Management_Deployment_IPackageInstallerInfo<D>::Scope() const
    {
        winrt::Microsoft::Management::Deployment::PackageInstallerScope value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageInstallerInfo)->get_Scope(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageInstallerInfo<D>::Locale() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageInstallerInfo)->get_Locale(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::ElevationRequirement) consume_Microsoft_Management_Deployment_IPackageInstallerInfo2<D>::ElevationRequirement() const
    {
        winrt::Microsoft::Management::Deployment::ElevationRequirement value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageInstallerInfo2)->get_ElevationRequirement(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageInstallerInfo) consume_Microsoft_Management_Deployment_IPackageInstallerInstalledStatus<D>::InstallerInfo() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageInstallerInstalledStatus)->get_InstallerInfo(&value));
        return winrt::Microsoft::Management::Deployment::PackageInstallerInfo{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::InstalledStatus>) consume_Microsoft_Management_Deployment_IPackageInstallerInstalledStatus<D>::InstallerInstalledStatus() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageInstallerInstalledStatus)->get_InstallerInstalledStatus(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::InstalledStatus>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageCatalogReference>) consume_Microsoft_Management_Deployment_IPackageManager<D>::GetPackageCatalogs() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager)->GetPackageCatalogs(&result));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageCatalogReference>{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageCatalogReference) consume_Microsoft_Management_Deployment_IPackageManager<D>::GetPredefinedPackageCatalog(winrt::Microsoft::Management::Deployment::PredefinedPackageCatalog const& predefinedPackageCatalog) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager)->GetPredefinedPackageCatalog(static_cast<int32_t>(predefinedPackageCatalog), &result));
        return winrt::Microsoft::Management::Deployment::PackageCatalogReference{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageCatalogReference) consume_Microsoft_Management_Deployment_IPackageManager<D>::GetLocalPackageCatalog(winrt::Microsoft::Management::Deployment::LocalPackageCatalog const& localPackageCatalog) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager)->GetLocalPackageCatalog(static_cast<int32_t>(localPackageCatalog), &result));
        return winrt::Microsoft::Management::Deployment::PackageCatalogReference{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageCatalogReference) consume_Microsoft_Management_Deployment_IPackageManager<D>::GetPackageCatalogByName(param::hstring const& catalogName) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager)->GetPackageCatalogByName(*(void**)(&catalogName), &result));
        return winrt::Microsoft::Management::Deployment::PackageCatalogReference{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageCatalogReference) consume_Microsoft_Management_Deployment_IPackageManager<D>::CreateCompositePackageCatalog(winrt::Microsoft::Management::Deployment::CreateCompositePackageCatalogOptions const& options) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager)->CreateCompositePackageCatalog(*(void**)(&options), &result));
        return winrt::Microsoft::Management::Deployment::PackageCatalogReference{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::InstallResult, winrt::Microsoft::Management::Deployment::InstallProgress>) consume_Microsoft_Management_Deployment_IPackageManager<D>::InstallPackageAsync(winrt::Microsoft::Management::Deployment::CatalogPackage const& package, winrt::Microsoft::Management::Deployment::InstallOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager)->InstallPackageAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::InstallResult, winrt::Microsoft::Management::Deployment::InstallProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::InstallResult, winrt::Microsoft::Management::Deployment::InstallProgress>) consume_Microsoft_Management_Deployment_IPackageManager2<D>::GetInstallProgress(winrt::Microsoft::Management::Deployment::CatalogPackage const& package, winrt::Microsoft::Management::Deployment::PackageCatalogInfo const& catalogInfo) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager2)->GetInstallProgress(*(void**)(&package), *(void**)(&catalogInfo), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::InstallResult, winrt::Microsoft::Management::Deployment::InstallProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::InstallResult, winrt::Microsoft::Management::Deployment::InstallProgress>) consume_Microsoft_Management_Deployment_IPackageManager3<D>::UpgradePackageAsync(winrt::Microsoft::Management::Deployment::CatalogPackage const& package, winrt::Microsoft::Management::Deployment::InstallOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager3)->UpgradePackageAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::InstallResult, winrt::Microsoft::Management::Deployment::InstallProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::UninstallResult, winrt::Microsoft::Management::Deployment::UninstallProgress>) consume_Microsoft_Management_Deployment_IPackageManager3<D>::UninstallPackageAsync(winrt::Microsoft::Management::Deployment::CatalogPackage const& package, winrt::Microsoft::Management::Deployment::UninstallOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager3)->UninstallPackageAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::UninstallResult, winrt::Microsoft::Management::Deployment::UninstallProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::UninstallResult, winrt::Microsoft::Management::Deployment::UninstallProgress>) consume_Microsoft_Management_Deployment_IPackageManager3<D>::GetUninstallProgress(winrt::Microsoft::Management::Deployment::CatalogPackage const& package, winrt::Microsoft::Management::Deployment::PackageCatalogInfo const& catalogInfo) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager3)->GetUninstallProgress(*(void**)(&package), *(void**)(&catalogInfo), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::UninstallResult, winrt::Microsoft::Management::Deployment::UninstallProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::DownloadResult, winrt::Microsoft::Management::Deployment::PackageDownloadProgress>) consume_Microsoft_Management_Deployment_IPackageManager4<D>::DownloadPackageAsync(winrt::Microsoft::Management::Deployment::CatalogPackage const& package, winrt::Microsoft::Management::Deployment::DownloadOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager4)->DownloadPackageAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::DownloadResult, winrt::Microsoft::Management::Deployment::PackageDownloadProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::DownloadResult, winrt::Microsoft::Management::Deployment::PackageDownloadProgress>) consume_Microsoft_Management_Deployment_IPackageManager4<D>::GetDownloadProgress(winrt::Microsoft::Management::Deployment::CatalogPackage const& package, winrt::Microsoft::Management::Deployment::PackageCatalogInfo const& catalogInfo) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManager4)->GetDownloadProgress(*(void**)(&package), *(void**)(&catalogInfo), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::DownloadResult, winrt::Microsoft::Management::Deployment::PackageDownloadProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IPackageManagerSettings<D>::SetCallerIdentifier(param::hstring const& callerIdentifier) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManagerSettings)->SetCallerIdentifier(*(void**)(&callerIdentifier), &result));
        return result;
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IPackageManagerSettings<D>::SetStateIdentifier(param::hstring const& stateIdentifier) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManagerSettings)->SetStateIdentifier(*(void**)(&stateIdentifier), &result));
        return result;
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IPackageManagerSettings<D>::SetUserSettings(param::hstring const& settingsContent) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageManagerSettings)->SetUserSettings(*(void**)(&settingsContent), &result));
        return result;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageFieldMatchOption) consume_Microsoft_Management_Deployment_IPackageMatchFilter<D>::Option() const
    {
        winrt::Microsoft::Management::Deployment::PackageFieldMatchOption value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageMatchFilter)->get_Option(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IPackageMatchFilter<D>::Option(winrt::Microsoft::Management::Deployment::PackageFieldMatchOption const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageMatchFilter)->put_Option(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageMatchField) consume_Microsoft_Management_Deployment_IPackageMatchFilter<D>::Field() const
    {
        winrt::Microsoft::Management::Deployment::PackageMatchField value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageMatchFilter)->get_Field(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IPackageMatchFilter<D>::Field(winrt::Microsoft::Management::Deployment::PackageMatchField const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageMatchFilter)->put_Field(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageMatchFilter<D>::Value() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageMatchFilter)->get_Value(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IPackageMatchFilter<D>::Value(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageMatchFilter)->put_Value(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageVersionId<D>::PackageCatalogId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionId)->get_PackageCatalogId(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageVersionId<D>::Version() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionId)->get_Version(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageVersionId<D>::Channel() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionId)->get_Channel(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageVersionInfo<D>::GetMetadata(winrt::Microsoft::Management::Deployment::PackageVersionMetadataField const& metadataField) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo)->GetMetadata(static_cast<int32_t>(metadataField), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageVersionInfo<D>::Id() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo)->get_Id(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageVersionInfo<D>::DisplayName() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo)->get_DisplayName(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageVersionInfo<D>::Version() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo)->get_Version(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageVersionInfo<D>::Channel() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo)->get_Channel(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<hstring>) consume_Microsoft_Management_Deployment_IPackageVersionInfo<D>::PackageFamilyNames() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo)->get_PackageFamilyNames(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVectorView<hstring>) consume_Microsoft_Management_Deployment_IPackageVersionInfo<D>::ProductCodes() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo)->get_ProductCodes(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageCatalog) consume_Microsoft_Management_Deployment_IPackageVersionInfo<D>::PackageCatalog() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo)->get_PackageCatalog(&value));
        return winrt::Microsoft::Management::Deployment::PackageCatalog{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::CompareResult) consume_Microsoft_Management_Deployment_IPackageVersionInfo2<D>::CompareToVersion(param::hstring const& versionString) const
    {
        winrt::Microsoft::Management::Deployment::CompareResult result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo2)->CompareToVersion(*(void**)(&versionString), reinterpret_cast<int32_t*>(&result)));
        return result;
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IPackageVersionInfo3<D>::HasApplicableInstaller(winrt::Microsoft::Management::Deployment::InstallOptions const& options) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo3)->HasApplicableInstaller(*(void**)(&options), &result));
        return result;
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IPackageVersionInfo3<D>::Publisher() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo3)->get_Publisher(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::CatalogPackageMetadata) consume_Microsoft_Management_Deployment_IPackageVersionInfo4<D>::GetCatalogPackageMetadata() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo4)->GetCatalogPackageMetadata(&result));
        return winrt::Microsoft::Management::Deployment::CatalogPackageMetadata{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::CatalogPackageMetadata) consume_Microsoft_Management_Deployment_IPackageVersionInfo4<D>::GetCatalogPackageMetadata(param::hstring const& preferredLocale) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo4)->GetCatalogPackageMetadata2(*(void**)(&preferredLocale), &result));
        return winrt::Microsoft::Management::Deployment::CatalogPackageMetadata{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageInstallerInfo) consume_Microsoft_Management_Deployment_IPackageVersionInfo4<D>::GetApplicableInstaller(winrt::Microsoft::Management::Deployment::InstallOptions const& options) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IPackageVersionInfo4)->GetApplicableInstaller(*(void**)(&options), &result));
        return winrt::Microsoft::Management::Deployment::PackageInstallerInfo{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ISourceAgreement<D>::Label() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ISourceAgreement)->get_Label(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ISourceAgreement<D>::Text() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ISourceAgreement)->get_Text(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_ISourceAgreement<D>::Url() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::ISourceAgreement)->get_Url(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageVersionId) consume_Microsoft_Management_Deployment_IUninstallOptions<D>::PackageVersionId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions)->get_PackageVersionId(&value));
        return winrt::Microsoft::Management::Deployment::PackageVersionId{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IUninstallOptions<D>::PackageVersionId(winrt::Microsoft::Management::Deployment::PackageVersionId const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions)->put_PackageVersionId(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageUninstallMode) consume_Microsoft_Management_Deployment_IUninstallOptions<D>::PackageUninstallMode() const
    {
        winrt::Microsoft::Management::Deployment::PackageUninstallMode value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions)->get_PackageUninstallMode(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IUninstallOptions<D>::PackageUninstallMode(winrt::Microsoft::Management::Deployment::PackageUninstallMode const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions)->put_PackageUninstallMode(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IUninstallOptions<D>::LogOutputPath() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions)->get_LogOutputPath(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IUninstallOptions<D>::LogOutputPath(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions)->put_LogOutputPath(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IUninstallOptions<D>::CorrelationData() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions)->get_CorrelationData(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IUninstallOptions<D>::CorrelationData(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions)->put_CorrelationData(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IUninstallOptions2<D>::Force() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions2)->get_Force(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IUninstallOptions2<D>::Force(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions2)->put_Force(value));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::PackageUninstallScope) consume_Microsoft_Management_Deployment_IUninstallOptions2<D>::PackageUninstallScope() const
    {
        winrt::Microsoft::Management::Deployment::PackageUninstallScope value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions2)->get_PackageUninstallScope(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Management_Deployment_IUninstallOptions2<D>::PackageUninstallScope(winrt::Microsoft::Management::Deployment::PackageUninstallScope const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallOptions2)->put_PackageUninstallScope(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Management_Deployment_IUninstallResult<D>::CorrelationData() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallResult)->get_CorrelationData(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Management_Deployment_IUninstallResult<D>::RebootRequired() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallResult)->get_RebootRequired(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Management::Deployment::UninstallResultStatus) consume_Microsoft_Management_Deployment_IUninstallResult<D>::Status() const
    {
        winrt::Microsoft::Management::Deployment::UninstallResultStatus value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallResult)->get_Status(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::hresult) consume_Microsoft_Management_Deployment_IUninstallResult<D>::ExtendedErrorCode() const
    {
        winrt::hresult value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallResult)->get_ExtendedErrorCode(put_abi(value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(uint32_t) consume_Microsoft_Management_Deployment_IUninstallResult<D>::UninstallerErrorCode() const
    {
        uint32_t value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Management::Deployment::IUninstallResult)->get_UninstallerErrorCode(&value));
        return value;
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IAuthenticationArguments> : produce_base<D, winrt::Microsoft::Management::Deployment::IAuthenticationArguments>
    {
        int32_t __stdcall get_AuthenticationMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::AuthenticationMode>(this->shim().AuthenticationMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AuthenticationMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AuthenticationMode(*reinterpret_cast<winrt::Microsoft::Management::Deployment::AuthenticationMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AuthenticationAccount(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().AuthenticationAccount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AuthenticationAccount(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AuthenticationAccount(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IAuthenticationInfo> : produce_base<D, winrt::Microsoft::Management::Deployment::IAuthenticationInfo>
    {
        int32_t __stdcall get_AuthenticationType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::AuthenticationType>(this->shim().AuthenticationType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MicrosoftEntraIdAuthenticationInfo(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::MicrosoftEntraIdAuthenticationInfo>(this->shim().MicrosoftEntraIdAuthenticationInfo());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::ICatalogPackage> : produce_base<D, winrt::Microsoft::Management::Deployment::ICatalogPackage>
    {
        int32_t __stdcall get_Id(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InstalledVersion(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageVersionInfo>(this->shim().InstalledVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AvailableVersions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageVersionId>>(this->shim().AvailableVersions());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DefaultInstallVersion(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageVersionInfo>(this->shim().DefaultInstallVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPackageVersionInfo(void* versionKey, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::PackageVersionInfo>(this->shim().GetPackageVersionInfo(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageVersionId const*>(&versionKey)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsUpdateAvailable(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsUpdateAvailable());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::ICatalogPackage2> : produce_base<D, winrt::Microsoft::Management::Deployment::ICatalogPackage2>
    {
        int32_t __stdcall CheckInstalledStatusAsync(uint32_t checkTypes, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult>>(this->shim().CheckInstalledStatusAsync(*reinterpret_cast<winrt::Microsoft::Management::Deployment::InstalledStatusType const*>(&checkTypes)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CheckInstalledStatus(uint32_t checkTypes, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult>(this->shim().CheckInstalledStatus(*reinterpret_cast<winrt::Microsoft::Management::Deployment::InstalledStatusType const*>(&checkTypes)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CheckInstalledStatusAsync2(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult>>(this->shim().CheckInstalledStatusAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CheckInstalledStatus2(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult>(this->shim().CheckInstalledStatus());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata> : produce_base<D, winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata>
    {
        int32_t __stdcall get_Locale(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Locale());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Publisher(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Publisher());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PublisherUrl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PublisherUrl());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PublisherSupportUrl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PublisherSupportUrl());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PrivacyUrl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PrivacyUrl());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Author(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Author());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageUrl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageUrl());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_License(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().License());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LicenseUrl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().LicenseUrl());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Copyright(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Copyright());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CopyrightUrl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().CopyrightUrl());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShortDescription(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ShortDescription());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Description(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Description());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Tags(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<hstring>>(this->shim().Tags());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Agreements(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageAgreement>>(this->shim().Agreements());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Documentations(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::Documentation>>(this->shim().Documentations());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Icons(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::Icon>>(this->shim().Icons());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReleaseNotes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ReleaseNotes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReleaseNotesUrl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ReleaseNotesUrl());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PurchaseUrl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PurchaseUrl());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InstallationNotes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().InstallationNotes());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::ICheckInstalledStatusResult> : produce_base<D, winrt::Microsoft::Management::Deployment::ICheckInstalledStatusResult>
    {
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::CheckInstalledStatusResultStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageInstalledStatus(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageInstallerInstalledStatus>>(this->shim().PackageInstalledStatus());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IConnectResult> : produce_base<D, winrt::Microsoft::Management::Deployment::IConnectResult>
    {
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::ConnectResultStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageCatalog(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageCatalog>(this->shim().PackageCatalog());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::ICreateCompositePackageCatalogOptions> : produce_base<D, winrt::Microsoft::Management::Deployment::ICreateCompositePackageCatalogOptions>
    {
        int32_t __stdcall get_Catalogs(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Management::Deployment::PackageCatalogReference>>(this->shim().Catalogs());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CompositeSearchBehavior(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::CompositeSearchBehavior>(this->shim().CompositeSearchBehavior());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CompositeSearchBehavior(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CompositeSearchBehavior(*reinterpret_cast<winrt::Microsoft::Management::Deployment::CompositeSearchBehavior const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::ICreateCompositePackageCatalogOptions2> : produce_base<D, winrt::Microsoft::Management::Deployment::ICreateCompositePackageCatalogOptions2>
    {
        int32_t __stdcall get_InstalledScope(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageInstallScope>(this->shim().InstalledScope());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InstalledScope(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InstalledScope(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageInstallScope const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IDocumentation> : produce_base<D, winrt::Microsoft::Management::Deployment::IDocumentation>
    {
        int32_t __stdcall get_DocumentLabel(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DocumentLabel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DocumentUrl(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DocumentUrl());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IDownloadOptions> : produce_base<D, winrt::Microsoft::Management::Deployment::IDownloadOptions>
    {
        int32_t __stdcall get_PackageVersionId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageVersionId>(this->shim().PackageVersionId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageVersionId(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageVersionId(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageVersionId const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InstallerType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageInstallerType>(this->shim().InstallerType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InstallerType(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InstallerType(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageInstallerType const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Scope(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageInstallScope>(this->shim().Scope());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Scope(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Scope(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageInstallScope const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Architecture(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::System::ProcessorArchitecture>(this->shim().Architecture());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Architecture(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Architecture(*reinterpret_cast<winrt::Windows::System::ProcessorArchitecture const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Locale(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Locale());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Locale(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Locale(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DownloadDirectory(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DownloadDirectory());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DownloadDirectory(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DownloadDirectory(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowHashMismatch(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowHashMismatch());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowHashMismatch(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowHashMismatch(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SkipDependencies(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().SkipDependencies());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SkipDependencies(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SkipDependencies(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AcceptPackageAgreements(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AcceptPackageAgreements());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AcceptPackageAgreements(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AcceptPackageAgreements(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CorrelationData(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().CorrelationData());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CorrelationData(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CorrelationData(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IDownloadResult> : produce_base<D, winrt::Microsoft::Management::Deployment::IDownloadResult>
    {
        int32_t __stdcall get_CorrelationData(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().CorrelationData());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::DownloadResultStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendedErrorCode(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().ExtendedErrorCode());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IFindPackagesOptions> : produce_base<D, winrt::Microsoft::Management::Deployment::IFindPackagesOptions>
    {
        int32_t __stdcall get_Selectors(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Management::Deployment::PackageMatchFilter>>(this->shim().Selectors());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Filters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Management::Deployment::PackageMatchFilter>>(this->shim().Filters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ResultLimit(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ResultLimit());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ResultLimit(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ResultLimit(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IFindPackagesResult> : produce_base<D, winrt::Microsoft::Management::Deployment::IFindPackagesResult>
    {
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::FindPackagesResultStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Matches(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::MatchResult>>(this->shim().Matches());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_WasLimitExceeded(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().WasLimitExceeded());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IIcon> : produce_base<D, winrt::Microsoft::Management::Deployment::IIcon>
    {
        int32_t __stdcall get_Url(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Url());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FileType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::IconFileType>(this->shim().FileType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Resolution(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::IconResolution>(this->shim().Resolution());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Theme(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::IconTheme>(this->shim().Theme());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Sha256(uint32_t* __valueSize, uint8_t** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueSize, *value) = detach_abi(this->shim().Sha256());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IInstallOptions> : produce_base<D, winrt::Microsoft::Management::Deployment::IInstallOptions>
    {
        int32_t __stdcall get_PackageVersionId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageVersionId>(this->shim().PackageVersionId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageVersionId(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageVersionId(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageVersionId const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreferredInstallLocation(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PreferredInstallLocation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreferredInstallLocation(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreferredInstallLocation(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageInstallScope(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageInstallScope>(this->shim().PackageInstallScope());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageInstallScope(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageInstallScope(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageInstallScope const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageInstallMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageInstallMode>(this->shim().PackageInstallMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageInstallMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageInstallMode(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageInstallMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LogOutputPath(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().LogOutputPath());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LogOutputPath(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LogOutputPath(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowHashMismatch(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowHashMismatch());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowHashMismatch(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowHashMismatch(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ReplacementInstallerArguments(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ReplacementInstallerArguments());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ReplacementInstallerArguments(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReplacementInstallerArguments(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CorrelationData(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().CorrelationData());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CorrelationData(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CorrelationData(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AdditionalPackageCatalogArguments(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().AdditionalPackageCatalogArguments());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AdditionalPackageCatalogArguments(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AdditionalPackageCatalogArguments(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IInstallOptions2> : produce_base<D, winrt::Microsoft::Management::Deployment::IInstallOptions2>
    {
        int32_t __stdcall get_AllowedArchitectures(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::System::ProcessorArchitecture>>(this->shim().AllowedArchitectures());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IInstallOptions3> : produce_base<D, winrt::Microsoft::Management::Deployment::IInstallOptions3>
    {
        int32_t __stdcall get_AllowUpgradeToUnknownVersion(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowUpgradeToUnknownVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowUpgradeToUnknownVersion(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowUpgradeToUnknownVersion(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IInstallOptions4> : produce_base<D, winrt::Microsoft::Management::Deployment::IInstallOptions4>
    {
        int32_t __stdcall get_Force(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Force());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Force(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Force(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IInstallOptions5> : produce_base<D, winrt::Microsoft::Management::Deployment::IInstallOptions5>
    {
        int32_t __stdcall get_AdditionalInstallerArguments(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().AdditionalInstallerArguments());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AdditionalInstallerArguments(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AdditionalInstallerArguments(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AcceptPackageAgreements(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AcceptPackageAgreements());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AcceptPackageAgreements(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AcceptPackageAgreements(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BypassIsStoreClientBlockedPolicyCheck(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().BypassIsStoreClientBlockedPolicyCheck());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_BypassIsStoreClientBlockedPolicyCheck(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BypassIsStoreClientBlockedPolicyCheck(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IInstallOptions6> : produce_base<D, winrt::Microsoft::Management::Deployment::IInstallOptions6>
    {
        int32_t __stdcall get_SkipDependencies(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().SkipDependencies());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SkipDependencies(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SkipDependencies(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InstallerType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageInstallerType>(this->shim().InstallerType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InstallerType(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InstallerType(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageInstallerType const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IInstallResult> : produce_base<D, winrt::Microsoft::Management::Deployment::IInstallResult>
    {
        int32_t __stdcall get_CorrelationData(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().CorrelationData());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RebootRequired(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RebootRequired());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::InstallResultStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendedErrorCode(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().ExtendedErrorCode());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IInstallResult2> : produce_base<D, winrt::Microsoft::Management::Deployment::IInstallResult2>
    {
        int32_t __stdcall get_InstallerErrorCode(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().InstallerErrorCode());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IInstalledStatus> : produce_base<D, winrt::Microsoft::Management::Deployment::IInstalledStatus>
    {
        int32_t __stdcall get_Type(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::InstalledStatusType>(this->shim().Type());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Path(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Path());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IMatchResult> : produce_base<D, winrt::Microsoft::Management::Deployment::IMatchResult>
    {
        int32_t __stdcall get_CatalogPackage(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::CatalogPackage>(this->shim().CatalogPackage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MatchCriteria(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageMatchFilter>(this->shim().MatchCriteria());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IMicrosoftEntraIdAuthenticationInfo> : produce_base<D, winrt::Microsoft::Management::Deployment::IMicrosoftEntraIdAuthenticationInfo>
    {
        int32_t __stdcall get_Resource(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Resource());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Scope(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Scope());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageAgreement> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageAgreement>
    {
        int32_t __stdcall get_Label(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Label());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Text(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Text());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Url(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Url());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageCatalog> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageCatalog>
    {
        int32_t __stdcall get_IsComposite(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsComposite());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Info(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageCatalogInfo>(this->shim().Info());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindPackagesAsync(void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::FindPackagesResult>>(this->shim().FindPackagesAsync(*reinterpret_cast<winrt::Microsoft::Management::Deployment::FindPackagesOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindPackages(void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::FindPackagesResult>(this->shim().FindPackages(*reinterpret_cast<winrt::Microsoft::Management::Deployment::FindPackagesOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageCatalogInfo> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageCatalogInfo>
    {
        int32_t __stdcall get_Id(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Type(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Type());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Argument(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Argument());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LastUpdateTime(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::DateTime>(this->shim().LastUpdateTime());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Origin(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageCatalogOrigin>(this->shim().Origin());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TrustLevel(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageCatalogTrustLevel>(this->shim().TrustLevel());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference>
    {
        int32_t __stdcall get_IsComposite(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsComposite());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Info(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageCatalogInfo>(this->shim().Info());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ConnectAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Management::Deployment::ConnectResult>>(this->shim().ConnectAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Connect(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::ConnectResult>(this->shim().Connect());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference2> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference2>
    {
        int32_t __stdcall get_AdditionalPackageCatalogArguments(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().AdditionalPackageCatalogArguments());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AdditionalPackageCatalogArguments(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AdditionalPackageCatalogArguments(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference3> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference3>
    {
        int32_t __stdcall get_SourceAgreements(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::SourceAgreement>>(this->shim().SourceAgreements());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AcceptSourceAgreements(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AcceptSourceAgreements());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AcceptSourceAgreements(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AcceptSourceAgreements(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference4> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference4>
    {
        int32_t __stdcall get_PackageCatalogBackgroundUpdateInterval(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::TimeSpan>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::TimeSpan>(this->shim().PackageCatalogBackgroundUpdateInterval());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageCatalogBackgroundUpdateInterval(int64_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageCatalogBackgroundUpdateInterval(*reinterpret_cast<winrt::Windows::Foundation::TimeSpan const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference5> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference5>
    {
        int32_t __stdcall get_InstalledPackageInformationOnly(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().InstalledPackageInformationOnly());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InstalledPackageInformationOnly(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InstalledPackageInformationOnly(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference6> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageCatalogReference6>
    {
        int32_t __stdcall get_AuthenticationArguments(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::AuthenticationArguments>(this->shim().AuthenticationArguments());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AuthenticationArguments(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AuthenticationArguments(*reinterpret_cast<winrt::Microsoft::Management::Deployment::AuthenticationArguments const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AuthenticationInfo(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::AuthenticationInfo>(this->shim().AuthenticationInfo());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageInstallerInfo> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageInstallerInfo>
    {
        int32_t __stdcall get_InstallerType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageInstallerType>(this->shim().InstallerType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NestedInstallerType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageInstallerType>(this->shim().NestedInstallerType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Architecture(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::System::ProcessorArchitecture>(this->shim().Architecture());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Scope(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageInstallerScope>(this->shim().Scope());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Locale(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Locale());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageInstallerInfo2> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageInstallerInfo2>
    {
        int32_t __stdcall get_ElevationRequirement(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::ElevationRequirement>(this->shim().ElevationRequirement());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageInstallerInstalledStatus> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageInstallerInstalledStatus>
    {
        int32_t __stdcall get_InstallerInfo(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageInstallerInfo>(this->shim().InstallerInfo());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InstallerInstalledStatus(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::InstalledStatus>>(this->shim().InstallerInstalledStatus());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageManager> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageManager>
    {
        int32_t __stdcall GetPackageCatalogs(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Management::Deployment::PackageCatalogReference>>(this->shim().GetPackageCatalogs());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPredefinedPackageCatalog(int32_t predefinedPackageCatalog, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::PackageCatalogReference>(this->shim().GetPredefinedPackageCatalog(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PredefinedPackageCatalog const*>(&predefinedPackageCatalog)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetLocalPackageCatalog(int32_t localPackageCatalog, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::PackageCatalogReference>(this->shim().GetLocalPackageCatalog(*reinterpret_cast<winrt::Microsoft::Management::Deployment::LocalPackageCatalog const*>(&localPackageCatalog)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPackageCatalogByName(void* catalogName, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::PackageCatalogReference>(this->shim().GetPackageCatalogByName(*reinterpret_cast<hstring const*>(&catalogName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateCompositePackageCatalog(void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::PackageCatalogReference>(this->shim().CreateCompositePackageCatalog(*reinterpret_cast<winrt::Microsoft::Management::Deployment::CreateCompositePackageCatalogOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InstallPackageAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::InstallResult, winrt::Microsoft::Management::Deployment::InstallProgress>>(this->shim().InstallPackageAsync(*reinterpret_cast<winrt::Microsoft::Management::Deployment::CatalogPackage const*>(&package), *reinterpret_cast<winrt::Microsoft::Management::Deployment::InstallOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageManager2> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageManager2>
    {
        int32_t __stdcall GetInstallProgress(void* package, void* catalogInfo, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::InstallResult, winrt::Microsoft::Management::Deployment::InstallProgress>>(this->shim().GetInstallProgress(*reinterpret_cast<winrt::Microsoft::Management::Deployment::CatalogPackage const*>(&package), *reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageCatalogInfo const*>(&catalogInfo)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageManager3> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageManager3>
    {
        int32_t __stdcall UpgradePackageAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::InstallResult, winrt::Microsoft::Management::Deployment::InstallProgress>>(this->shim().UpgradePackageAsync(*reinterpret_cast<winrt::Microsoft::Management::Deployment::CatalogPackage const*>(&package), *reinterpret_cast<winrt::Microsoft::Management::Deployment::InstallOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall UninstallPackageAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::UninstallResult, winrt::Microsoft::Management::Deployment::UninstallProgress>>(this->shim().UninstallPackageAsync(*reinterpret_cast<winrt::Microsoft::Management::Deployment::CatalogPackage const*>(&package), *reinterpret_cast<winrt::Microsoft::Management::Deployment::UninstallOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetUninstallProgress(void* package, void* catalogInfo, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::UninstallResult, winrt::Microsoft::Management::Deployment::UninstallProgress>>(this->shim().GetUninstallProgress(*reinterpret_cast<winrt::Microsoft::Management::Deployment::CatalogPackage const*>(&package), *reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageCatalogInfo const*>(&catalogInfo)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageManager4> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageManager4>
    {
        int32_t __stdcall DownloadPackageAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::DownloadResult, winrt::Microsoft::Management::Deployment::PackageDownloadProgress>>(this->shim().DownloadPackageAsync(*reinterpret_cast<winrt::Microsoft::Management::Deployment::CatalogPackage const*>(&package), *reinterpret_cast<winrt::Microsoft::Management::Deployment::DownloadOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDownloadProgress(void* package, void* catalogInfo, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Management::Deployment::DownloadResult, winrt::Microsoft::Management::Deployment::PackageDownloadProgress>>(this->shim().GetDownloadProgress(*reinterpret_cast<winrt::Microsoft::Management::Deployment::CatalogPackage const*>(&package), *reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageCatalogInfo const*>(&catalogInfo)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageManagerSettings> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageManagerSettings>
    {
        int32_t __stdcall SetCallerIdentifier(void* callerIdentifier, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().SetCallerIdentifier(*reinterpret_cast<hstring const*>(&callerIdentifier)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetStateIdentifier(void* stateIdentifier, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().SetStateIdentifier(*reinterpret_cast<hstring const*>(&stateIdentifier)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetUserSettings(void* settingsContent, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().SetUserSettings(*reinterpret_cast<hstring const*>(&settingsContent)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageMatchFilter> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageMatchFilter>
    {
        int32_t __stdcall get_Option(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageFieldMatchOption>(this->shim().Option());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Option(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Option(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageFieldMatchOption const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Field(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageMatchField>(this->shim().Field());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Field(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Field(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageMatchField const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Value(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Value(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Value(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageVersionId> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageVersionId>
    {
        int32_t __stdcall get_PackageCatalogId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageCatalogId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Version(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Version());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Channel(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Channel());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageVersionInfo> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageVersionInfo>
    {
        int32_t __stdcall GetMetadata(int32_t metadataField, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetMetadata(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageVersionMetadataField const*>(&metadataField)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Id(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DisplayName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DisplayName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Version(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Version());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Channel(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Channel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageFamilyNames(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<hstring>>(this->shim().PackageFamilyNames());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProductCodes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<hstring>>(this->shim().ProductCodes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageCatalog(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageCatalog>(this->shim().PackageCatalog());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageVersionInfo2> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageVersionInfo2>
    {
        int32_t __stdcall CompareToVersion(void* versionString, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::CompareResult>(this->shim().CompareToVersion(*reinterpret_cast<hstring const*>(&versionString)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageVersionInfo3> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageVersionInfo3>
    {
        int32_t __stdcall HasApplicableInstaller(void* options, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().HasApplicableInstaller(*reinterpret_cast<winrt::Microsoft::Management::Deployment::InstallOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Publisher(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Publisher());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IPackageVersionInfo4> : produce_base<D, winrt::Microsoft::Management::Deployment::IPackageVersionInfo4>
    {
        int32_t __stdcall GetCatalogPackageMetadata(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::CatalogPackageMetadata>(this->shim().GetCatalogPackageMetadata());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetCatalogPackageMetadata2(void* preferredLocale, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::CatalogPackageMetadata>(this->shim().GetCatalogPackageMetadata(*reinterpret_cast<hstring const*>(&preferredLocale)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetApplicableInstaller(void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Management::Deployment::PackageInstallerInfo>(this->shim().GetApplicableInstaller(*reinterpret_cast<winrt::Microsoft::Management::Deployment::InstallOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::ISourceAgreement> : produce_base<D, winrt::Microsoft::Management::Deployment::ISourceAgreement>
    {
        int32_t __stdcall get_Label(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Label());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Text(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Text());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Url(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Url());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IUninstallOptions> : produce_base<D, winrt::Microsoft::Management::Deployment::IUninstallOptions>
    {
        int32_t __stdcall get_PackageVersionId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageVersionId>(this->shim().PackageVersionId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageVersionId(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageVersionId(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageVersionId const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageUninstallMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageUninstallMode>(this->shim().PackageUninstallMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageUninstallMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageUninstallMode(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageUninstallMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LogOutputPath(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().LogOutputPath());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LogOutputPath(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LogOutputPath(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CorrelationData(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().CorrelationData());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CorrelationData(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CorrelationData(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IUninstallOptions2> : produce_base<D, winrt::Microsoft::Management::Deployment::IUninstallOptions2>
    {
        int32_t __stdcall get_Force(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Force());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Force(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Force(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageUninstallScope(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::PackageUninstallScope>(this->shim().PackageUninstallScope());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageUninstallScope(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageUninstallScope(*reinterpret_cast<winrt::Microsoft::Management::Deployment::PackageUninstallScope const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Management::Deployment::IUninstallResult> : produce_base<D, winrt::Microsoft::Management::Deployment::IUninstallResult>
    {
        int32_t __stdcall get_CorrelationData(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().CorrelationData());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RebootRequired(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RebootRequired());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Management::Deployment::UninstallResultStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendedErrorCode(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().ExtendedErrorCode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UninstallerErrorCode(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().UninstallerErrorCode());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Management::Deployment
{
    constexpr auto operator|(InstalledStatusType const left, InstalledStatusType const right) noexcept
    {
        return static_cast<InstalledStatusType>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(InstalledStatusType& left, InstalledStatusType const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(InstalledStatusType const left, InstalledStatusType const right) noexcept
    {
        return static_cast<InstalledStatusType>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(InstalledStatusType& left, InstalledStatusType const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(InstalledStatusType const value) noexcept
    {
        return static_cast<InstalledStatusType>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(InstalledStatusType const left, InstalledStatusType const right) noexcept
    {
        return static_cast<InstalledStatusType>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(InstalledStatusType& left, InstalledStatusType const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline AuthenticationArguments::AuthenticationArguments() :
        AuthenticationArguments(impl::call_factory_cast<AuthenticationArguments(*)(winrt::Windows::Foundation::IActivationFactory const&), AuthenticationArguments>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<AuthenticationArguments>(); }))
    {
    }
    inline CreateCompositePackageCatalogOptions::CreateCompositePackageCatalogOptions() :
        CreateCompositePackageCatalogOptions(impl::call_factory_cast<CreateCompositePackageCatalogOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), CreateCompositePackageCatalogOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<CreateCompositePackageCatalogOptions>(); }))
    {
    }
    inline DownloadOptions::DownloadOptions() :
        DownloadOptions(impl::call_factory_cast<DownloadOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), DownloadOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<DownloadOptions>(); }))
    {
    }
    inline FindPackagesOptions::FindPackagesOptions() :
        FindPackagesOptions(impl::call_factory_cast<FindPackagesOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), FindPackagesOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<FindPackagesOptions>(); }))
    {
    }
    inline InstallOptions::InstallOptions() :
        InstallOptions(impl::call_factory_cast<InstallOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), InstallOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<InstallOptions>(); }))
    {
    }
    inline PackageManager::PackageManager() :
        PackageManager(impl::call_factory_cast<PackageManager(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageManager>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageManager>(); }))
    {
    }
    inline PackageManagerSettings::PackageManagerSettings() :
        PackageManagerSettings(impl::call_factory_cast<PackageManagerSettings(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageManagerSettings>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageManagerSettings>(); }))
    {
    }
    inline PackageMatchFilter::PackageMatchFilter() :
        PackageMatchFilter(impl::call_factory_cast<PackageMatchFilter(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageMatchFilter>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageMatchFilter>(); }))
    {
    }
    inline UninstallOptions::UninstallOptions() :
        UninstallOptions(impl::call_factory_cast<UninstallOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), UninstallOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<UninstallOptions>(); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Management::Deployment::IAuthenticationArguments> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IAuthenticationInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::ICatalogPackage> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::ICatalogPackage2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::ICatalogPackageMetadata> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::ICheckInstalledStatusResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IConnectResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::ICreateCompositePackageCatalogOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::ICreateCompositePackageCatalogOptions2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IDocumentation> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IDownloadOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IDownloadResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IFindPackagesOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IFindPackagesResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IIcon> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IInstallOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IInstallOptions2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IInstallOptions3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IInstallOptions4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IInstallOptions5> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IInstallOptions6> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IInstallResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IInstallResult2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IInstalledStatus> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IMatchResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IMicrosoftEntraIdAuthenticationInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageAgreement> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageCatalog> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageCatalogInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageCatalogReference> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageCatalogReference2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageCatalogReference3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageCatalogReference4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageCatalogReference5> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageCatalogReference6> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageInstallerInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageInstallerInfo2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageInstallerInstalledStatus> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageManager2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageManager3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageManager4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageManagerSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageMatchFilter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageVersionId> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageVersionInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageVersionInfo2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageVersionInfo3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IPackageVersionInfo4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::ISourceAgreement> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IUninstallOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IUninstallOptions2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::IUninstallResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::AuthenticationArguments> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::AuthenticationInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::CatalogPackage> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::CatalogPackageMetadata> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::CheckInstalledStatusResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::ConnectResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::CreateCompositePackageCatalogOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::Documentation> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::DownloadOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::DownloadResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::FindPackagesOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::FindPackagesResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::Icon> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::InstallOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::InstallResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::InstalledStatus> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::MatchResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::MicrosoftEntraIdAuthenticationInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::PackageAgreement> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::PackageCatalog> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::PackageCatalogInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::PackageCatalogReference> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::PackageInstallerInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::PackageInstallerInstalledStatus> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::PackageManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::PackageManagerSettings> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::PackageMatchFilter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::PackageVersionId> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::PackageVersionInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::SourceAgreement> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::UninstallOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Management::Deployment::UninstallResult> : winrt::impl::hash_base {};
#endif
}
#endif
